app.py:
# Full updated app.py - replace the entire content with this
from flask import Flask, render_template, request, jsonify
import logging
import sys
from backend.models import UserGoalInput
from backend.validators import validate_goal, validate_location
from backend.resume_extractor import extract_text_from_file
from backend.prompt_builder import build_career_roadmap_prompt
from backend.openai_client import call_openai_gpt4
from backend.perplexity_prompt_builder import build_perplexity_prompt
# --- NEW IMPORT ---
from backend.perplexity_client import call_perplexity_api
# --- END NEW IMPORT ---
import tempfile
import os
from dotenv import load_dotenv
import re
import json

load_dotenv()
logging.basicConfig(level=logging.DEBUG, format='%(asctime)s %(levelname)s %(message)s')

app = Flask(__name__, template_folder='templates', static_folder='static')

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/generate_prompt', methods=['POST'])
def generate_prompt():
    logging.debug("Processing /generate_prompt request")
    try:
        goal = request.form.get('goal')
        location = request.form.get('location')
        resume_file = request.files.get('resume')

        if not goal or not location:
            return jsonify({'error': 'Goal and location are required'}), 400

        user_input = UserGoalInput(five_year_goal=goal, location=location)
        goal = user_input.five_year_goal
        location = user_input.location

        resume_text = None
        if resume_file:
            allowed_extensions = {'pdf', 'docx', 'txt'}
            if resume_file.filename.split('.')[-1].lower() not in allowed_extensions:
                return jsonify({'error': 'Invalid file type'}), 400
            if len(resume_file.read()) > 500 * 1024:
                return jsonify({'error': 'Resume too large (max 500KB)'}), 400
            resume_file.seek(0)
            ext = '.' + resume_file.filename.split('.')[-1].lower()
            with tempfile.NamedTemporaryFile(delete=False, suffix=ext) as tmp:
                resume_file.save(tmp.name)
                resume_text = extract_text_from_file(tmp.name)
            os.unlink(tmp.name)
            if not resume_text:
                return jsonify({'error': 'Failed to extract text from resume'}), 400
            if len(resume_text) > 10000:
                return jsonify({'error': 'Resume too long (max ~2 pages)'}), 400

        resume_snippet = resume_text[:3000] if resume_text else ""

        openai_prompt = build_career_roadmap_prompt(goal, location, resume_snippet)
        openai_response = call_openai_gpt4(openai_prompt)

        clean_response = re.sub(r"^```(?:json)?\s*|```$", "", openai_response.strip(), flags=re.MULTILINE)
        try:
            roadmap_obj = json.loads(clean_response)
            roadmap_json = json.dumps(roadmap_obj, indent=2)
        except json.JSONDecodeError as e:
            logging.error(f"Failed to parse OpenAI response as JSON: {e}")
            return jsonify({'error': "OpenAI response wasn't valid JSON"}), 400

        # --- PERPLEXITY LOGIC ACTIVATED ---
        try:
            perplexity_prompt = build_perplexity_prompt(
                roadmap_json=roadmap_json,
                resume_snippet=resume_snippet,
                location=location
            )
            print("\n--- PROMPT SENT TO PERPLEXITY ---\n")
            print(perplexity_prompt)
            
            # --- LIVE API CALL ACTIVATED ---
            print("\n--- CALLING PERPLEXITY API... ---\n")
            market_report = call_perplexity_api(perplexity_prompt)
            if market_report:  # Check if the response is non-empty
                print("\n--- MARKET INTELLIGENCE REPORT FROM PERPLEXITY ---\n")
                print(market_report)
            # --- END OF PERPLEXITY CALL ---

        except Exception as e:
            logging.error(f"Failed during Perplexity stage: {e}")
            pass

        return jsonify({'roadmap': roadmap_json})

    except ValueError as e:
        logging.error(f"Validation error: {e}")
        return jsonify({'error': str(e)}), 400
    except Exception as e:
        logging.error(f"Top-level error in /generate_prompt: {e}")
        return jsonify({'error': 'A critical server error occurred.'}), 500

if __name__ == '__main__':
    app.run(debug=True)

============================================================

backend\__init__.py:


============================================================

backend\models.py:
from pydantic import BaseModel, constr

class UserGoalInput(BaseModel):
    five_year_goal: constr(strip_whitespace=True, min_length=10)
    location: constr(strip_whitespace=True, min_length=2) 

============================================================

backend\openai_client.py:
# backend/openai_client.py
import os
import logging
import openai
import sys
from dotenv import load_dotenv
from openai import OpenAIError

load_dotenv()
logging.debug(f"Loaded environment: PYTHONPATH={os.environ.get('PYTHONPATH')}, CWD={os.getcwd()}, Executable={sys.executable}")

OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

if not OPENAI_API_KEY:
    raise ValueError("OPENAI_API_KEY not found in environment variables.")

client = openai.OpenAI(api_key=OPENAI_API_KEY)

def call_openai_gpt4(prompt: str) -> str:
    logging.info("Sending prompt to OpenAI o3-mini...")
    try:
        response = client.chat.completions.create(
            model="o3-mini",
            messages=[
                {"role": "system", "content": "You are a helpful assistant."},
                {"role": "user", "content": prompt}
            ],
            max_completion_tokens=4000,  # Correct parameter for o3-mini
        )
        result = response.choices[0].message.content
        logging.info(f"o3-mini response received: {result}")
        print("\n--- OPENAI o3-mini RESPONSE ---\n")
        print(result)
        return result
    except openai.OpenAIError as e:
        logging.error(f"OpenAI API error: {str(e)} - Details: {e.__dict__}")
        print(f"Error calling OpenAI o3-mini: {str(e)}")
        return ""
    except Exception as e:
        logging.error(f"Unexpected error calling OpenAI: {str(e)}")
        print(f"Error calling OpenAI o3-mini: {str(e)}")
        return ""

============================================================

backend\perplexity_client.py:
# backend/perplexity_client.py
import os
import logging
import requests

def call_perplexity_api(prompt: str) -> str:
    """
    Sends a prompt to the Perplexity API and returns the response.
    """
    api_key = os.getenv("PERPLEXITY_API_KEY")
    if not api_key:
        logging.error("PERPLEXITY_API_KEY environment variable not set")
        return "Error: Perplexity API key not configured."

    url = "https://api.perplexity.ai/chat/completions"
    headers = {
        "Authorization": f"Bearer {api_key}",
        "Content-Type": "application/json"
    }
    
    payload = {
        "model": "sonar-medium-online",
        "messages": [
            {"role": "user", "content": prompt}
        ],
        "max_tokens": 4096,
        "stream": False  # Explicitly set to match non-streaming intent
    }
    
    logging.info("Sending prompt to Perplexity...")
    
    try:
        response = requests.post(url, headers=headers, json=payload, timeout=90)
        response.raise_for_status()
        
        result = response.json()
        content = result["choices"][0]["message"]["content"]
        
        logging.info(f"Perplexity response received: {len(content)} characters")
        return content
        
    except requests.exceptions.RequestException as e:
        logging.error(f"Perplexity API request failed: {e}")
        return f"Error communicating with Perplexity API: {e}"
    except KeyError as e:
        logging.error(f"Unexpected response format from Perplexity: {e}")
        return "Error: Unexpected response format from Perplexity."
    except Exception as e:
        logging.error(f"An unexpected error occurred: {e}")
        return "An unexpected error occurred while calling Perplexity."

============================================================

backend\perplexity_prompt_builder.py:
# backend/perplexity_prompt_builder.py
import textwrap
import logging
import json

# This function is a placeholder. In a real app, you'd have more robust resume parsing.
def _convert_resume_to_json(resume_text: str) -> str:
    """A simple fallback for converting resume text to a JSON object."""
    logging.info("Converting resume snippet to JSON for Perplexity prompt.")
    # For now, we'll just wrap the text in a simple JSON structure.
    return json.dumps({"resume_summary": resume_text}, indent=2)

def build_perplexity_prompt(roadmap_json: str, resume_snippet: str, location: str) -> str:
    """
    Builds a hyper-specific, structured prompt for Perplexity to generate a 
    market intelligence report.
    """
    logging.info("Building hyper-personalized Perplexity prompt...")
    
    resume_json_str = _convert_resume_to_json(resume_snippet)
    
    # This is the prompt structure from your CLI version.
    header = textwrap.dedent(f"""
        You are **MarketIntelPro**, an expert market-intelligence assistant. Your analysis must be forensic, data-driven, and directly tied to the user's provided information. You will produce a deep, action-oriented report that maps every insight back to the user's 5-year career roadmap and resume.

        **Location:** {location}

        **User Resume (JSON):**
        ```json
        {resume_json_str}
        ```

        **5-Year Roadmap (JSON):**
        ```json
        {roadmap_json}
        ```

        **Sources to Prioritize:** 1) LinkedIn  
        2) Tech News & Company Blogs  
        3) Local Event Aggregators (e.g., Meetup.com) in the user's location
        4) Reddit (for anecdotal signals)
    """).strip()

    # --- REFINED INSTRUCTIONS ---
    # These instructions are more forceful and provide a clear formula for the AI.
    tasks = textwrap.dedent("""
        ### Core Task & Analysis Formula

        Your task is to generate a market intelligence report by executing the following formula. You must find real, verifiable data from your online sources.

        **1. Executive Summary:**
           - Write a 2-3 sentence summary of the key market opportunities that align with the user's overall 5-year goal.

        **2. Per-Year Analysis (Repeat for Each of the 5 Years):**
           - **Restate the Goal:** Begin with a markdown header: `## Analysis for Year X: "{The user's goal for that year}"`
           - **Market Signal Validation:** Find one specific, current market trend or technology demand that validates this yearly goal. State the trend and cite your source with a URL.
           - **Actionable Intelligence (2 Items Required):** Provide exactly two distinct, actionable items that directly support this goal. For each item, you must include a justification.
             - **Item 1:** [Name of Event/Company/Course] - [Link]
               - **Justification:** Explain *why* this is a perfect fit by referencing a specific detail from the user's resume. (e.g., "Based on your resume's mention of `PowerShell`, this `Azure DevOps` workshop is a logical next step...")
             - **Item 2:** [Name of Event/Company/Course] - [Link]
               - **Justification:** Explain *why* this is a perfect fit by referencing a different detail from the user's resume.

        **3. Final Checklist:**
           - Conclude with a "Next Steps" checklist. You must use the user's exact Q1-Q4 goal language from the roadmap JSON.
    """).strip()

    # The output structure provides a clear template for the AI to follow.
    output_structure = textwrap.dedent("""
        ### Expected Report Structure (Use this Markdown format exactly)

        # Market Intelligence Report

        ## Executive Summary
        ...

        ---

        ## Analysis for Year 5: "{Year 5 Goal Text}"
        - **Market Signal:** ... [*Source URL*]
        - **Actionable Intelligence:**
            1.  **[Event/Company/Course Name]:** ... [*Link to item*]
                - **Justification:** Based on your resume's mention of `...`, this is relevant because ...
            2.  **[Event/Company/Course Name]:** ... [*Link to item*]
                - **Justification:** Your experience with `...` makes this an ideal opportunity to ...

        (Repeat the analysis structure for Years 4, 3, 2, and 1)

        ---

        ### Next Steps
        - [ ] **Q1:** {user's Q1 goal text}
        - [ ] **Q2:** {user's Q2 goal text}
        - [ ] **Q3:** {user's Q3 goal text}
        - [ ] **Q4:** {user's Q4 goal text}
    """).strip()

    prompt = "\n\n".join([header, tasks, output_structure])
    logging.info(f"Built hyper-personalized Perplexity prompt ({len(prompt)} chars)")
    return prompt


============================================================

backend\prompt_builder.py:
# backend/prompt_builder.py
import logging
import textwrap

MAX_RESUME_CHARS = 3000  # hard cap to keep the prompt ≤ GPT-4 limits

def build_career_roadmap_prompt(goal: str, location: str, resume_text: str | None = None) -> str:
    logging.info("Building roadmap prompt…")

    chunks: list[str] = [
        textwrap.dedent(f"""
            You are **Strat-AI**, an elite, data-driven career strategist. Your sole function is to perform a rigorous gap analysis between a user's resume and their stated goal. You are meticulous and hyper-realistic. Every single goal you propose must be directly justified by a specific detail from the user's resume and location. You do not give generic advice.

            Context:
            - User's 5‑year goal: "{goal}"
            - User's location:   "{location}"
        """).strip()
    ]

    if resume_text:
        # Escape triple quotes to prevent f-string issues
        safe_resume = resume_text.replace('"""', '\\"""')
        resume_chunk = textwrap.indent(safe_resume, "    ")
        chunks.append(
            "- User's resume:\n" +
            resume_chunk
        )

    # Updated instructions with new JSON schema including SMART breakdown
    chunks.append(textwrap.dedent("""
        Instructions:
        1. Analyze and Identify Gaps: First, scrutinize the user's resume and identify the top 3-5 critical skill, certification, or experience gaps between their current state and their 5-year goal.
        2. Plan Backwards to Close Gaps: Plan backwards from Year 5. Each `year_goal` must be a logical milestone that explicitly closes one of the gaps you identified.
        3. Justify Year 1 Quarterly Goals: For Year 1, create exactly four distinct quarterly goals. Each `goal` must provide a brief summary, and include a detailed SMART breakdown.
        4. JSON Schema: Return **only** valid JSON matching this structure:
        {
          "five_year_goal": "...",
          "location": "...",
          "yearly_goals": [
            {"year": 5, "year_goal": "..."},
            {"year": 4, "year_goal": "..."},
            {"year": 3, "year_goal": "..."},
            {"year": 2, "year_goal": "..."},
            {
              "year": 1,
              "year_goal": "...",
              "quarterly_smart_goals": [
                {
                  "quarter": "Q1",
                  "goal": "A brief summary of the quarterly goal.",
                  "smart": {
                    "S": "Specific: A detailed explanation of the specific task.",
                    "M": "Measurable: How progress will be measured.",
                    "A": "Achievable: Why this goal is achievable.",
                    "R": "Relevant: How this goal is relevant to the 5-year plan.",
                    "T": "Time-bound: The specific deadline for this goal."
                  }
                },
                {
                  "quarter": "Q2",
                  "goal": "A brief summary of the quarterly goal.",
                  "smart": {
                    "S": "Specific: A detailed explanation of the specific task.",
                    "M": "Measurable: How progress will be measured.",
                    "A": "Achievable: Why this goal is achievable.",
                    "R": "Relevant: How this goal is relevant to the 5-year plan.",
                    "T": "Time-bound: The specific deadline for this goal."
                  }
                },
                {
                  "quarter": "Q3",
                  "goal": "A brief summary of the quarterly goal.",
                  "smart": {
                    "S": "Specific: A detailed explanation of the specific task.",
                    "M": "Measurable: How progress will be measured.",
                    "A": "Achievable: Why this goal is achievable.",
                    "R": "Relevant: How this goal is relevant to the 5-year plan.",
                    "T": "Time-bound: The specific deadline for this goal."
                  }
                },
                {
                  "quarter": "Q4",
                  "goal": "A brief summary of the quarterly goal.",
                  "smart": {
                    "S": "Specific: A detailed explanation of the specific task.",
                    "M": "Measurable: How progress will be measured.",
                    "A": "Achievable: Why this goal is achievable.",
                    "R": "Relevant: How this goal is relevant to the 5-year plan.",
                    "T": "Time-bound: The specific deadline for this goal."
                  }
                }
              ]
            }
          ]
        }

        Rules:
        - Hyper-Personalization Mandate: Every quarterly goal for Year 1 must begin by referencing a specific detail from the user's resume. No exceptions. A generic goal like "Obtain a certification" is unacceptable. It must be "Leveraging your `CompTIA Security+`, you will now pursue the `CompTIA CySA+` to build on your security foundation."
        - Location-Awareness: Integrate the user's location (`Tucson, AZ`) where relevant, such as suggesting specific local networking events, companies, or regional industry trends.
        - No Generic Verbs: Avoid vague verbs like "learn," "improve," or "work on." Use concrete action verbs like "implement," "deploy," "master," "achieve," "attain," or "lead."
        - JSON only, no markdown or prose.
        - If not enough details are available in the resume, avoid overcompensating and play it safe; do the best you can with what you have but don’t squeeze juice out of it if it’s not there.
    """).strip())

    prompt = "\n\n".join(chunks)
    logging.info("Prompt built successfully.")
    return prompt

============================================================

backend\resume_extractor.py:
import logging
from pathlib import Path
from typing import Final

import pdfplumber
from docx import Document   # pip install python-docx

MIN_CHARS: Final[int] = 50   # treat anything shorter as “no resume”

def extract_text_from_file(path: str | Path) -> str:
    """
    Returns plaintext from PDF, DOCX, or TXT.
    If the file can’t be read or is too short, returns an empty string.
    """
    path = Path(path)
    logging.info("Extracting resume text from %s", path)

    try:
        match path.suffix.lower():
            case ".pdf":
                with pdfplumber.open(path) as pdf:
                    text = "\n".join(page.extract_text() or "" for page in pdf.pages)
            case ".docx":
                doc = Document(path)
                text = "\n".join(p.text for p in doc.paragraphs)
            case ".txt":
                text = path.read_text(encoding="utf-8")
            case _:
                logging.warning("Unsupported resume format: %s", path.suffix)
                return ""

        text = text.strip()
        if len(text) < MIN_CHARS:
            logging.warning("Resume text too short – treating as missing.")
            return ""

        logging.info("Resume extracted – %s characters", len(text))
        return text

    except Exception as exc:  # broad on purpose – we never want to crash the CLI
        logging.error("Failed to extract resume: %s", exc)
        return "" 

============================================================

backend\validators.py:
import re

def validate_goal(goal: str) -> str:
    goal = goal.strip()
    if len(goal) < 10:
        raise ValueError("5-year goal must be at least 10 characters long.")
    return goal

def validate_location(location: str) -> str:
    location = location.strip()
    # Enforce 'City, ST' format (US only)
    pattern = r'^[A-Za-z\s\-]{2,},\s*[A-Z]{2}$'
    if not re.match(pattern, location):
        raise ValueError('Location must be in the format "City, ST" (e.g., "Tucson, AZ")')
    return location 

============================================================

scrape_all_code.py:
import os

# Define the output file (overwrites each run)
output_file = "all_code_dump.txt"

# Define directories and files to exclude
exclude_dirs = {'.venv', '.env', '__pycache__', '.pytest_cache', 'site-packages', 'dist', 'build'}
exclude_files = {'.gitignore', 'requirements.txt', 'Procfile', 'README.md'}  # Auxiliary files to skip

# List of file types you want to include (your custom code)
included_extensions = {'.html', '.css', '.js', '.py'}

# Collect only your custom files from project directories
py_files = []

for root, dirs, files in os.walk('.'):
    # Modify dirs in place to skip excluded directories
    dirs[:] = [d for d in dirs if d not in exclude_dirs]
    
    # Only process files with your specified extensions, excluding auxiliary files
    for file in files:
        if (any(file.endswith(ext) for ext in included_extensions) and 
            file not in exclude_files):
            py_files.append(os.path.join(root, file))

# Write to output file, overwriting previous content
with open(output_file, 'w', encoding='utf-8') as out:
    for py_file in sorted(py_files):
        # Clean up the file path for display, removing leading ./ or \
        display_name = py_file.lstrip('./\\')
        out.write(f"{display_name}:\n")
        with open(py_file, 'r', encoding='utf-8') as f:
            out.write(f.read())
        out.write("\n\n" + "="*60 + "\n\n")

print(f"All custom code has been saved to {output_file}, overwriting previous content")

============================================================

static\css\style.css:
/* Reset and base styles */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: linear-gradient(135deg, #1e3c72, #2a5298);
    color: #e0e0e0;
    min-height: 100vh;
    padding: 20px;
    line-height: 1.6;
}

header {
    margin-bottom: 20px;
}

h1 {
    font-size: 2.5rem;
    color: #ffffff;
    text-align: center;
    text-transform: uppercase;
    letter-spacing: 2px;
}

main {
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    border-radius: 15px;
    padding: 30px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
}

form {
    display: grid;
    gap: 15px;
    max-width: 600px;
    margin: 0 auto 30px;
}

label {
    font-weight: 600;
    color: #d3d3d3;
}

input, button {
    padding: 10px;
    font-size: 1rem;
    border: none;
    border-radius: 5px;
    transition: all 0.3s ease;
}

input {
    background: rgba(255, 255, 255, 0.2);
    color: #fff;
}

input:focus {
    outline: none;
    background: rgba(255, 255, 255, 0.3);
    box-shadow: 0 0 5px #3498db;
}

button {
    background: linear-gradient(90deg, #3498db, #8e44ad);
    color: white;
    cursor: pointer;
}

button:hover {
    background: linear-gradient(90deg, #2980b9, #8e44ad);
    transform: translateY(-2px);
}

.error {
    color: #e74c3c;
    font-weight: bold;
    text-align: center;
    margin-top: 10px;
}

/* === ROADMAP VISUAL STYLES START === */
.roadmap-container {
    width: 100%;
    max-width: 700px;
    margin: 0 auto;
}

.roadmap-card {
    background: rgba(0, 0, 0, 0.2);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 20px;
    padding: 2.5rem;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    backdrop-filter: blur(10px);
    transition: all 0.3s ease;
}

.roadmap-card:hover {
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
    transform: translateY(-2px);
}

.roadmap-header {
    text-align: center;
    margin-bottom: 2.5rem;
    padding-bottom: 1.5rem;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.roadmap-title {
    font-size: 1.8rem;
    font-weight: 700;
    line-height: 1.3;
    margin-bottom: 0.5rem;
    background: linear-gradient(45deg, #3498db, #8e44ad);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.roadmap-location {
    font-size: 1rem;
    color: #bdc3c7;
    font-weight: 300;
}

.goals-section {
    margin-bottom: 1rem;
}

.goals-section:last-child {
    margin-bottom: 0;
}

.goal-item {
    margin-bottom: 1rem;
}

.goal-item:last-child {
    margin-bottom: 0;
}

.details-container {
    border: 1px solid rgba(255, 255, 255, 0.05);
    border-radius: 12px;
    overflow: hidden;
    transition: all 0.3s ease;
}

.details-container:hover {
    border-color: rgba(52, 152, 219, 0.3);
    background: rgba(255, 255, 255, 0.12);
}

.details-container[open] {
    border-color: #3498db;
    background: rgba(255, 255, 255, 0.12);
}

.summary-container {
    padding: 1.2rem 1.5rem;
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-weight: 600;
    font-size: 1.1rem;
    color: #ecf0f1;
    transition: all 0.2s ease;
    list-style: none;
}

.summary-container::-webkit-details-marker { display: none; }
.summary-container { display: list-item; }

.summary-container:hover {
    color: #3498db;
}

.chevron {
    width: 20px;
    height: 20px;
    transition: transform 0.3s ease;
    fill: #bdc3c7;
}

.details-container[open] .chevron {
    transform: rotate(180deg);
    fill: #3498db;
}

.details-content {
    padding: 0 1.5rem 1.5rem;
    color: #bdc3c7;
    line-height: 1.6;
}

.section-title {
    font-size: 1.4rem;
    font-weight: 600;
    color: #ecf0f1;
    margin-top: 2.5rem;
    margin-bottom: 1.5rem;
    padding-left: 1rem;
    border-left: 4px solid #3498db;
}

.quarter-label {
    font-weight: 700;
    color: #3498db;
    margin-right: 0.5rem;
}

.smart-breakdown {
    list-style: none;
    margin-top: 1rem;
}

.smart-item {
    display: flex;
    margin-bottom: 0.8rem;
    padding: 0.8rem;
    background: rgba(52, 152, 219, 0.05);
    border-radius: 6px;
    border-left: 3px solid #3498db;
}

.smart-label {
    font-weight: 600;
    color: #3498db;
    min-width: 80px;
    margin-right: 1rem;
}

.smart-text {
    color: #bdc3c7;
    line-height: 1.5;
}

/* Responsive design */
@media (max-width: 768px) {
    .roadmap-card { padding: 2rem; }
    .roadmap-title { font-size: 1.5rem; }
    .summary-container { font-size: 1rem; padding: 1rem; }
    .smart-item { flex-direction: column; padding: 0.6rem; }
    .smart-label { min-width: auto; margin-right: 0; margin-bottom: 0.3rem; }
}

@media (max-width: 480px) {
    .roadmap-card { padding: 1.5rem; }
    .roadmap-title { font-size: 1.3rem; }
    .summary-container { padding: 0.8rem; }
}
/* === ROADMAP VISUAL STYLES END === */

/* Dark mode adjustments */
@media (prefers-color-scheme: dark) {
    body {
        background: linear-gradient(135deg, #1a252f, #2c3e50);
    }
    main {
        background: rgba(0, 0, 0, 0.2);
    }
    input {
        background: rgba(0, 0, 0, 0.3);
    }
}

============================================================

static\js\script.js:
document.getElementById('uploadForm').addEventListener('submit', async function(event) {
    event.preventDefault();
    const formData = new FormData(this);
    const errorDiv = document.getElementById('error');
    const outputContainer = document.getElementById('roadmapCardContainer');

    errorDiv.textContent = '';
    outputContainer.innerHTML = '<p>Loading roadmap...</p>';

    // Client-side validation
    const resume = document.getElementById('resume').files[0];
    if (!resume) {
        errorDiv.textContent = 'Please upload a resume.';
        outputContainer.innerHTML = '';
        return;
    }
    if (resume.size > 500 * 1024) {
        errorDiv.textContent = 'Resume file too large (max 500KB).';
        outputContainer.innerHTML = '';
        return;
    }
    const goal = document.getElementById('goal').value.trim();
    if (goal.length < 10) {
        errorDiv.textContent = 'Goal must be at least 10 characters.';
        outputContainer.innerHTML = '';
        return;
    }
    const location = document.getElementById('location').value.trim();
    const locRegex = /^[A-Za-z\s\-]{2,},\s*[A-Z]{2}$/;
    if (!locRegex.test(location)) {
        errorDiv.textContent = 'Location must be in "City, ST" format.';
        outputContainer.innerHTML = '';
        return;
    }

    try {
        const response = await fetch('/generate_prompt', {
            method: 'POST',
            body: formData
        });
        const data = await response.json();
        outputContainer.innerHTML = '';

        if (data.error) {
            errorDiv.textContent = data.error;
        } else {
            try {
                const roadmapData = JSON.parse(data.roadmap);
                renderRoadmap(formatRoadmapData(roadmapData));
            } catch (e) {
                errorDiv.textContent = 'Error parsing roadmap data.';
                console.error('JSON parsing error:', e, 'Raw data:', data.roadmap);
            }
        }
    } catch (err) {
        outputContainer.innerHTML = '';
        errorDiv.textContent = 'Error connecting to server. Please try again.';
        console.error('Fetch error:', err);
    }
});

/**
 * Formats and validates the roadmap data to prevent rendering errors.
 * @param {Object} data - Raw roadmap data from OpenAI
 * @returns {Object} - A safe, structured roadmap data object
 */
function formatRoadmapData(data) {
    const formatted = {
        five_year_goal: data.five_year_goal || 'Goal not specified.',
        location: data.location || 'Location not specified.',
        yearly_goals: Array.isArray(data.yearly_goals) ? data.yearly_goals : []
    };

    // FIX: Corrected typo from 'yearsly_goals' to 'yearly_goals'
    formatted.yearly_goals = formatted.yearly_goals
        .sort((a, b) => (b.year || 0) - (a.year || 0))
        .map(year => {
            const yearData = {
                year: year.year || 'N/A',
                year_goal: year.year_goal || 'Yearly goal not specified.',
                quarterly_smart_goals: []
            };
            if (year.year === 1 && Array.isArray(year.quarterly_smart_goals)) {
                yearData.quarterly_smart_goals = year.quarterly_smart_goals.map(q => ({
                    quarter: q.quarter || 'Q?',
                    goal: q.goal || 'Quarterly goal not specified.',
                    smart: q.smart || { S: '', M: '', A: '', R: '', T: '' }
                }));
            }
            return yearData;
        });

    return formatted;
}

/**
 * Renders the interactive roadmap card component.
 * @param {Object} data - The formatted roadmap data object.
 */
function renderRoadmap(data) {
    console.log('Rendering roadmap:', data); // Debug log
    const container = document.getElementById('roadmapCardContainer');
    container.innerHTML = ''; // Clear loading text

    const card = document.createElement('div');
    card.className = 'roadmap-card';

    // --- 1. Header ---
    const header = document.createElement('div');
    header.className = 'roadmap-header';
    const title = document.createElement('h1');
    title.className = 'roadmap-title';
    title.textContent = data.five_year_goal;
    const location = document.createElement('p');
    location.className = 'roadmap-location';
    location.textContent = data.location;
    header.appendChild(title);
    header.appendChild(location);
    card.appendChild(header);

    // --- 2. Yearly Goals Section ---
    const yearlyGoalsSection = document.createElement('div');
    yearlyGoalsSection.className = 'goals-section';
    data.yearly_goals.forEach(yearData => {
        const goalItem = document.createElement('div');
        goalItem.className = 'goal-item';
        const details = document.createElement('details');
        details.className = 'details-container';
        const summary = document.createElement('summary');
        summary.className = 'summary-container';
        const yearText = document.createElement('span');
        yearText.textContent = `Year ${yearData.year}: ${yearData.year_goal}`;
        summary.appendChild(yearText);
        const chevron = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        chevron.setAttribute('class', 'chevron');
        chevron.setAttribute('viewBox', '0 0 24 24');
        chevron.innerHTML = '<path d="M7 14l5-5 5 5z"/>';
        summary.appendChild(chevron);
        details.appendChild(summary);
        goalItem.appendChild(details);
        yearlyGoalsSection.appendChild(goalItem);
    });
    card.appendChild(yearlyGoalsSection);

    // --- 3. Quarterly SMART Goals Section ---
    const year1Data = data.yearly_goals.find(y => y.year === 1);
    if (year1Data && year1Data.quarterly_smart_goals.length > 0) {
        const quarterlyGoalsSection = document.createElement('div');
        quarterlyGoalsSection.className = 'goals-section';
        const quarterlyTitle = document.createElement('h3');
        quarterlyTitle.className = 'section-title';
        quarterlyTitle.textContent = 'Quarterly SMART Goals for Year 1';
        quarterlyGoalsSection.appendChild(quarterlyTitle);

        year1Data.quarterly_smart_goals.forEach(quarterData => {
            const goalItem = document.createElement('div');
            goalItem.className = 'goal-item';
            const details = document.createElement('details');
            details.className = 'details-container';
            const summary = document.createElement('summary');
            summary.className = 'summary-container';
            const quarterText = document.createElement('span');
            const quarterLabel = document.createElement('span');
            quarterLabel.className = 'quarter-label';
            quarterLabel.textContent = quarterData.quarter + ':';
            quarterText.appendChild(quarterLabel);
            quarterText.appendChild(document.createTextNode(' ' + quarterData.goal));
            summary.appendChild(quarterText);
            const chevron = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            chevron.setAttribute('class', 'chevron');
            chevron.setAttribute('viewBox', '0 0 24 24');
            chevron.innerHTML = '<path d="M7 14l5-5 5 5z"/>';
            summary.appendChild(chevron);
            details.appendChild(summary);
            
            const content = document.createElement('div');
            content.className = 'details-content';
            if (quarterData.smart) {
                const smartList = document.createElement('ul');
                smartList.className = 'smart-breakdown';
                ['S', 'M', 'A', 'R', 'T'].forEach(key => {
                    if (quarterData.smart[key]) {
                        const smartItem = document.createElement('li');
                        smartItem.className = 'smart-item';
                        const smartLabel = document.createElement('span');
                        smartLabel.className = 'smart-label';
                        smartLabel.textContent = key + ':';
                        smartItem.appendChild(smartLabel);
                        const smartText = document.createElement('span');
                        smartText.className = 'smart-text';
                        smartText.textContent = quarterData.smart[key];
                        smartItem.appendChild(smartText);
                        smartList.appendChild(smartItem);
                    }
                });
                content.appendChild(smartList);
            }
            details.appendChild(content);
            goalItem.appendChild(details);
            quarterlyGoalsSection.appendChild(goalItem);
        });
        card.appendChild(quarterlyGoalsSection);
    }
    
    container.appendChild(card);
}

============================================================

templates\index.html:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Goal-to-Market UI Test</title>
    <link rel="stylesheet" href="/static/css/style.css">
</head>
<body>
    <header>
        <h1>Goal-to-Market Prompt Builder</h1>
    </header>
    <main>
        <form id="uploadForm">
            <label for="resume">Upload Resume (PDF, DOCX, TXT - max 2 pages):</label>
            <input type="file" id="resume" name="resume" accept=".pdf,.docx,.txt" required>
            <label for="goal">5-Year Career Goal (min 10 characters):</label>
            <input type="text" id="goal" name="goal" required>
            <label for="location">Location (City, ST format, e.g., Tucson, AZ):</label>
            <input type="text" id="location" name="location" required>
            <button type="submit">Generate Roadmap</button>
        </form>
        <div id="error" class="error"></div>
        <!-- Updated to roadmapCardContainer -->
        <div id="roadmapCardContainer"></div>
    </main>
    <script src="/static/js/script.js"></script>
</body>
</html>

============================================================

ui_test_app.py:
from flask import Flask, render_template, request, jsonify
from backend.resume_extractor import extract_text_from_file
from backend.prompt_builder import build_career_roadmap_prompt
from backend.validators import validate_goal, validate_location
import tempfile
import os
import logging

logging.basicConfig(level=logging.INFO)  # Consider DEBUG for more details if needed

app = Flask(__name__)

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/generate_prompt', methods=['POST'])
def generate_prompt():
    try:
        goal = request.form['goal']
        location = request.form['location']
        resume_file = request.files['resume']

        if not resume_file:
            return jsonify({'error': 'No resume uploaded'}), 400

        # Basic file validation (type and size for ~2 pages)
        allowed_extensions = {'pdf', 'docx', 'txt'}
        if resume_file.filename.split('.')[-1].lower() not in allowed_extensions:
            return jsonify({'error': 'Invalid file type (PDF, DOCX, TXT only)'}), 400

        # Temp save + extract (add original extension for format detection)
        ext = '.' + resume_file.filename.split('.')[-1].lower()
        with tempfile.NamedTemporaryFile(delete=False, suffix=ext) as tmp:
            resume_file.save(tmp.name)
            resume_text = extract_text_from_file(tmp.name)
        os.unlink(tmp.name)

        if not resume_text:
            return jsonify({'error': 'Failed to extract text from resume'}), 400

        # Enforce 2-page limit via text length (~10k chars max)
        if len(resume_text) > 10000:
            return jsonify({'error': 'Resume too long (max ~2 pages)'}), 400

        # Validate goal and location
        goal = validate_goal(goal)
        location = validate_location(location)

        # Build prompt
        prompt = build_career_roadmap_prompt(goal, location, resume_text)

        return jsonify({'prompt': prompt})

    except ValueError as e:
        return jsonify({'error': str(e)}), 400
    except Exception as e:
        logging.error(f"Error: {e}")
        return jsonify({'error': 'Server error - please try again'}), 500

if __name__ == '__main__':
    app.run(debug=True)

============================================================

